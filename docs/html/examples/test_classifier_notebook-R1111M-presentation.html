

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>RAM Computational Pipeline &mdash; PTSA 1.1.dev3 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="PTSA 1.1.dev3 documentation" href="../index.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> PTSA
          

          
          </a>

          
            
            
              <div class="version">
                1.1.dev3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial.html">PTSA Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ramdata.html">Interacting with RAM Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../filters.html">Filtering Time Series</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/index.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../development.html">Development guidelines</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">PTSA</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>RAM Computational Pipeline</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/examples/test_classifier_notebook-R1111M-presentation.ipynb.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS for nbsphinx extension */

/* remove conflicting styling from Sphinx themes */
div.nbinput,
div.nbinput div.prompt,
div.nbinput div.input_area,
div.nbinput div[class*=highlight],
div.nbinput div[class*=highlight] pre,
div.nboutput,
div.nbinput div.prompt,
div.nbinput div.output_area,
div.nboutput div[class*=highlight],
div.nboutput div[class*=highlight] pre {
    background: none;
    border: none;
    padding: 0 0;
    margin: 0;
    box-shadow: none;
}

/* avoid gaps between output lines */
div.nboutput div[class*=highlight] pre {
    line-height: normal;
}

/* input/output containers */
div.nbinput,
div.nboutput {
    display: -webkit-flex;
    display: flex;
    align-items: flex-start;
    margin: 0;
    width: 100%;
}
@media (max-width: 540px) {
    div.nbinput,
    div.nboutput {
        flex-direction: column;
    }
}

/* input container */
div.nbinput {
    padding-top: 5px;
}

/* last container */
div.nblast {
    padding-bottom: 5px;
}

/* input prompt */
div.nbinput div.prompt pre {
    color: #303F9F;
}

/* output prompt */
div.nboutput div.prompt pre {
    color: #D84315;
}

/* all prompts */
div.nbinput div.prompt,
div.nboutput div.prompt {
    min-width: 8ex;
    padding-top: 0.4em;
    padding-right: 0.4em;
    text-align: right;
    flex: 0;
}
@media (max-width: 540px) {
    div.nbinput div.prompt,
    div.nboutput div.prompt {
        text-align: left;
        padding: 0.4em;
    }
    div.nboutput div.prompt.empty {
        padding: 0;
    }
}

/* disable scrollbars on prompts */
div.nbinput div.prompt pre,
div.nboutput div.prompt pre {
    overflow: hidden;
}

/* input/output area */
div.nbinput div.input_area,
div.nboutput div.output_area {
    padding: 0.4em;
    -webkit-flex: 1;
    flex: 1;
    overflow: auto;
}
@media (max-width: 540px) {
    div.nbinput div.input_area,
    div.nboutput div.output_area {
        width: 100%;
    }
}

/* input area */
div.nbinput div.input_area {
    border: 1px solid #cfcfcf;
    border-radius: 2px;
    background: #f7f7f7;
}

/* override MathJax center alignment in output cells */
div.nboutput div[class*=MathJax] {
    text-align: left !important;
}

/* override sphinx.ext.pngmath center alignment in output cells */
div.nboutput div.math p {
    text-align: left;
}

/* standard error */
div.nboutput div.output_area.stderr {
    background: #fdd;
}

/* ANSI colors */
.ansi-black-fg { color: #3E424D; }
.ansi-black-bg { background-color: #3E424D; }
.ansi-black-intense-fg { color: #282C36; }
.ansi-black-intense-bg { background-color: #282C36; }
.ansi-red-fg { color: #E75C58; }
.ansi-red-bg { background-color: #E75C58; }
.ansi-red-intense-fg { color: #B22B31; }
.ansi-red-intense-bg { background-color: #B22B31; }
.ansi-green-fg { color: #00A250; }
.ansi-green-bg { background-color: #00A250; }
.ansi-green-intense-fg { color: #007427; }
.ansi-green-intense-bg { background-color: #007427; }
.ansi-yellow-fg { color: #DDB62B; }
.ansi-yellow-bg { background-color: #DDB62B; }
.ansi-yellow-intense-fg { color: #B27D12; }
.ansi-yellow-intense-bg { background-color: #B27D12; }
.ansi-blue-fg { color: #208FFB; }
.ansi-blue-bg { background-color: #208FFB; }
.ansi-blue-intense-fg { color: #0065CA; }
.ansi-blue-intense-bg { background-color: #0065CA; }
.ansi-magenta-fg { color: #D160C4; }
.ansi-magenta-bg { background-color: #D160C4; }
.ansi-magenta-intense-fg { color: #A03196; }
.ansi-magenta-intense-bg { background-color: #A03196; }
.ansi-cyan-fg { color: #60C6C8; }
.ansi-cyan-bg { background-color: #60C6C8; }
.ansi-cyan-intense-fg { color: #258F8F; }
.ansi-cyan-intense-bg { background-color: #258F8F; }
.ansi-white-fg { color: #C5C1B4; }
.ansi-white-bg { background-color: #C5C1B4; }
.ansi-white-intense-fg { color: #A1A6B2; }
.ansi-white-intense-bg { background-color: #A1A6B2; }

.ansi-bold { font-weight: bold; }

/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast,
.nboutput.nblast {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast + .nbinput {
    margin-top: -19px;
}

/* nice headers on first paragraph of info/warning boxes */
.admonition .first {
    margin: -12px;
    padding: 6px 12px;
    margin-bottom: 12px;
    color: #fff;
    line-height: 1;
    display: block;
}
.admonition.warning .first {
    background: #f0b37e;
}
.admonition.note .first {
    background: #6ab0de;
}
.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}
</style>
<div class="section" id="RAM-Computational-Pipeline">
<h1>RAM Computational Pipeline<a class="headerlink" href="#RAM-Computational-Pipeline" title="Permalink to this headline">¶</a></h1>
<p>This tutorial demonstrates how to build Logistic Regression Classifier
of Good memory for a single patient in 30 lines of code. The code is
based on the refactored PTSA toolkit that uses xarray as a core
container for the time series data. To construct classifier we will need
two classes of objects: 1. <strong>Readers</strong> 2. <strong>Filters</strong></p>
<p>Readers are objects that read data store on the hard drive. For the
purpose of building memory classifiers we need the following readers: 1.
<strong>BaseEventReader</strong> - an object that reads so called events files
(stored in Matlab format) 2. <strong>TalReader</strong> - an object that reads the so
called “Tal Structs” i.e. the information about pairing of bipolar
electrodes, location of electrods specified in various coordinates
systems and name of the brain areas where electrodes are placed. 3.
<strong>EEGReader</strong> - and object that reads raw EEG for specified events and
electrodes</p>
<p>We will use 3 filter objects: 1. <strong>MonopolarToBipolarFilter</strong> - an
onbject that takes as an input monopolar time series (as returned by
<strong>EEGReader</strong>) and returns another time series where for each bipolar
pair we form a series that is difference of two monopolar time series as
specified as given by the bipolar pair specification. For example, we
may have 100 monopolar electrodes but the number of bipolar pairs wcould
be 125 or so. <strong>MonopolarToBipolarFilter</strong> will transform an input time
series corresponding witj monopolar data to the one corresponding to
bipolar data 2. <strong>ButterworthFiler</strong> - an object that applies
Butterworth filter along time axis of the series. For example our time
series can be represented by a 3-dimensional array with dimensions
<em>“bipolar_pairs”</em>, <em>“events”</em> and <em>“time”</em>and in this case
<strong>ButterworthFilter</strong> will do filtering along <em>“time”</em> dimension 3.
<strong>MorletWaveletFilter</strong> - an object that takes as an input a time
series, applies continuous wavelet convolution along time axis and
returns another time series of wavelet coeeficients (represented as
power and phase arrays). For example our time series can be represented
by a 3-dimensional array with dimensions <em>“bipolar_pairs”</em>, <em>“events”</em>
and <em>“time”</em> and in this case <strong>MoreletWaveletFilter</strong> would return
4-dimensional array of wavelet coeeficients (power, phase) with
dimensions being <em>frequency</em>, <em>“bipolar_pairs”</em>, <em>“events”</em> and
<em>“time”</em>, where <em>frequency</em> is center wavelet frequency.</p>
<p>First let us start by importing modules/classes that we will need in our
computational pipeline:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [1]:
</pre></div>
</div>
<div class="input_area highlight-ipython2"><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;/Users/m/PTSA_NEW_GIT/&#39;</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">numpy.testing</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">ptsa.data.readers</span> <span class="kn">import</span> <span class="n">BaseEventReader</span>
<span class="kn">from</span> <span class="nn">ptsa.data.readers.TalReader</span> <span class="kn">import</span> <span class="n">TalReader</span>
<span class="kn">from</span> <span class="nn">ptsa.data.readers</span> <span class="kn">import</span> <span class="n">EEGReader</span>
<span class="kn">from</span> <span class="nn">ptsa.data.filters</span> <span class="kn">import</span> <span class="n">MonopolarToBipolarMapper</span>
<span class="kn">from</span> <span class="nn">ptsa.data.filters</span> <span class="kn">import</span> <span class="n">ButterworthFilter</span>
<span class="kn">from</span> <span class="nn">ptsa.data.filters.MorletWaveletFilter</span> <span class="kn">import</span> <span class="n">MorletWaveletFilter</span>
<span class="kn">from</span> <span class="nn">ptsa.data.common</span> <span class="kn">import</span> <span class="n">xr</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LogisticRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">roc_auc_score</span><span class="p">,</span> <span class="n">roc_curve</span>
<span class="kn">from</span> <span class="nn">scipy.stats.mstats</span> <span class="kn">import</span> <span class="n">zscore</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">time</span>
<span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Could not find compiled version of c library for handing edf files. If you want edf support, please run setup.py and compile this library
</pre></div></div>
</div>
<p>Notice that I manually appended a path <em>/Users/m/PTSA_NEW_GIT/</em> to
point Python to the location of the PTSA package. If you installed PTSA
into your default directory you can skip this step but if you get
stragne import errors it is a reasonable initial guess to ass=ume that
Python is unable to find PTSA and in this case specifying location of
PTSA should resolve the problems. Once our imports suceed we will
specify paths to events and “tal structs” files and read the content of
those:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [2]:
</pre></div>
</div>
<div class="input_area highlight-ipython2"><div class="highlight"><pre>
<span></span><span class="n">e_path</span> <span class="o">=</span> <span class="s1">&#39;/Users/m/data/events/RAM_FR1/R1111M_events.mat&#39;</span>
<span class="n">tal_path</span> <span class="o">=</span> <span class="s1">&#39;/Users/m/data/eeg/R1111M/tal/R1111M_talLocs_database_bipol.mat&#39;</span>
<span class="c1"># ------------------- READING TAL STRUCTS</span>
<span class="n">tal_reader</span> <span class="o">=</span> <span class="n">TalReader</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="n">tal_path</span><span class="p">)</span>
<span class="n">monopolar_channels</span> <span class="o">=</span> <span class="n">tal_reader</span><span class="o">.</span><span class="n">get_monopolar_channels</span><span class="p">()</span>
<span class="n">bipolar_pairs</span> <span class="o">=</span> <span class="n">tal_reader</span><span class="o">.</span><span class="n">get_bipolar_pairs</span><span class="p">()</span>
<span class="c1"># ------------------- READING EVENTS</span>
<span class="n">base_e_reader</span> <span class="o">=</span> <span class="n">BaseEventReader</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="n">e_path</span><span class="p">,</span> <span class="n">eliminate_events_with_no_eeg</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">base_events</span> <span class="o">=</span> <span class="n">base_e_reader</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="n">base_events</span> <span class="o">=</span> <span class="n">base_events</span><span class="p">[</span><span class="n">base_events</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;WORD&#39;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<p>After we read events and “tal structs” we are ready to read raw eeg
<strong>monopolar</strong> data. To do that we create an EEGReader object passing the
following information as arguments of the constructor:</p>
<ol class="arabic simple">
<li><em>events</em> - numpy recarray storing the content of events file</li>
<li><em>channels</em> - numpy array of monopolar channel labels</li>
<li><em>start_time</em> - an offset expressed in units of seconds that
specifies where the read statrts relative the to event position in
the eeg file</li>
<li><em>end_time</em> - an offset expressed in units of seconds that determines
where the read ends rrelative the to event position in the eeg file</li>
<li><em>buffer_time</em> - extra buffer (specified in units of seconds) added
before start_time_position and after end_time position</li>
</ol>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [3]:
</pre></div>
</div>
<div class="input_area highlight-ipython2"><div class="highlight"><pre>
<span></span><span class="n">eeg_reader</span> <span class="o">=</span> <span class="n">EEGReader</span><span class="p">(</span><span class="n">events</span><span class="o">=</span><span class="n">base_events</span><span class="p">,</span> <span class="n">channels</span><span class="o">=</span><span class="n">monopolar_channels</span><span class="p">,</span>
                       <span class="n">start_time</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">end_time</span><span class="o">=</span><span class="mf">1.6</span><span class="p">,</span> <span class="n">buffer_time</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>

<span class="n">base_eegs</span> <span class="o">=</span> <span class="n">eeg_reader</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</pre></div>
</div>
</div>
<p>At this point all the data necessary to construct our memory classifier
is loaded into computer memory and we are ready to process it. Since we
are interested in looing at potential difference between electrodes we
will first need to transform monopolar data to the the one where time
series are differences between appropriate monopolar data.It is
instructive to look at the raw eeg data. Notice that I shortened the
output by using <em>base_eegs[0:2,0:2,0:300]</em></p>
<div class="nbinput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [4]:
</pre></div>
</div>
<div class="input_area highlight-ipython2"><div class="highlight"><pre>
<span></span><span class="n">base_eegs</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">300</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>Out[4]:
</pre></div>
</div>
<div class="output_area highlight-none"><div class="highlight"><pre>
<span></span>&lt;xray.TimeSeriesX (channels: 2, events: 2, time: 300)&gt;
array([[[ 3467.059196,  3471.312604,  3473.970984, ...,  3565.950932,
          3574.989424,  3576.052776],
        [ 3609.548364,  3609.548364,  3612.73842 , ...,  3552.659032,
          3548.405624,  3543.62054 ]],

       [[-3652.082444, -3648.360712, -3645.170656, ..., -3497.896404,
         -3497.364728, -3505.339868],
        [-3565.950932, -3568.609312, -3573.394396, ..., -3492.047968,
         -3489.389588, -3483.009476]]])
Coordinates:
    samplerate  float64 499.7
  * channels    (channels) |S3 &#39;001&#39; &#39;002&#39;
  * events      (events) (numpy.record, [(&#39;subject&#39;, &#39;S256&#39;), (&#39;session&#39;, &#39;&lt;i8&#39;), (&#39;list&#39;, &#39;&lt;i8&#39;), (&#39;serialpos&#39;, &#39;&lt;i8&#39;), (&#39;type&#39;, &#39;S256&#39;), (&#39;item&#39;, &#39;S256&#39;), (&#39;itemno&#39;, &#39;&lt;i8&#39;), (&#39;recalled&#39;, &#39;&lt;i8&#39;), (&#39;mstime&#39;, &#39;&lt;f8&#39;), (&#39;msoffset&#39;, &#39;&lt;i8&#39;), (&#39;rectime&#39;, &#39;&lt;i8&#39;), (&#39;intrusion&#39;, &#39;&lt;i8&#39;), (&#39;isStim&#39;, &#39;&lt;i8&#39;), (&#39;expVersion&#39;, &#39;S256&#39;), (&#39;stimLoc&#39;, &#39;S256&#39;), (&#39;stimAmp&#39;, &#39;&lt;f8&#39;), (&#39;stimAnode&#39;, &#39;&lt;f8&#39;), (&#39;stimCathode&#39;, &#39;&lt;f8&#39;), (&#39;stimList&#39;, &#39;&lt;i8&#39;), (&#39;eegfile&#39;, &#39;S256&#39;), (&#39;eegoffset&#39;, &#39;&lt;i8&#39;)]) (&#39;R1111M&#39;, 0, 1, 1, &#39;WORD&#39;, &#39;BEAR&#39;, 17, 1, 1453499295325.0, 1, 5211, -999, 0, &#39;v_1.05&#39;, &#39;X&#39;, nan, nan, nan, 0, &#39;/Users/m/data/eeg/R1111M/eeg.noreref/R1111M_FR1_0_22Jan16_1638&#39;, 100521) ...
  * time        (time) float64 -1.0 -0.998 -0.996 -0.994 -0.992 -0.99 -0.988 ...
Attributes:
    samplerate: 499.71
    gain: 0.531676
    format: int16
</pre></div>
</div>
</div>
<p>As we can see raw EEG data (<em>base_eegs</em>) is a 3D array with axes
corresponding to <em>channels</em>, <em>events</em> and <em>time</em>. To access a single
time seriec for a given channel (say channel 0 where zero refers to
index of the channel not its label) and a given event (say 0th event) we
would type:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [5]:
</pre></div>
</div>
<div class="input_area highlight-ipython2"><div class="highlight"><pre>
<span></span><span class="n">base_eegs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>Out[5]:
</pre></div>
</div>
<div class="output_area highlight-none"><div class="highlight"><pre>
<span></span>&lt;xray.TimeSeriesX (time: 1800)&gt;
array([ 3467.059196,  3471.312604,  3473.970984, ...,  3580.306184,
        3581.901212,  3588.813   ])
Coordinates:
    samplerate  float64 499.7
    channels    |S3 &#39;001&#39;
    events      (numpy.record, [(&#39;subject&#39;, &#39;S256&#39;), (&#39;session&#39;, &#39;&lt;i8&#39;), (&#39;list&#39;, &#39;&lt;i8&#39;), (&#39;serialpos&#39;, &#39;&lt;i8&#39;), (&#39;type&#39;, &#39;S256&#39;), (&#39;item&#39;, &#39;S256&#39;), (&#39;itemno&#39;, &#39;&lt;i8&#39;), (&#39;recalled&#39;, &#39;&lt;i8&#39;), (&#39;mstime&#39;, &#39;&lt;f8&#39;), (&#39;msoffset&#39;, &#39;&lt;i8&#39;), (&#39;rectime&#39;, &#39;&lt;i8&#39;), (&#39;intrusion&#39;, &#39;&lt;i8&#39;), (&#39;isStim&#39;, &#39;&lt;i8&#39;), (&#39;expVersion&#39;, &#39;S256&#39;), (&#39;stimLoc&#39;, &#39;S256&#39;), (&#39;stimAmp&#39;, &#39;&lt;f8&#39;), (&#39;stimAnode&#39;, &#39;&lt;f8&#39;), (&#39;stimCathode&#39;, &#39;&lt;f8&#39;), (&#39;stimList&#39;, &#39;&lt;i8&#39;), (&#39;eegfile&#39;, &#39;S256&#39;), (&#39;eegoffset&#39;, &#39;&lt;i8&#39;)]) (&#39;R1111M&#39;, 0, 1, 1, &#39;WORD&#39;, &#39;BEAR&#39;, 17, 1, 1453499295325.0, 1, 5211, -999, 0, &#39;v_1.05&#39;, &#39;X&#39;, nan, nan, nan, 0, &#39;/Users/m/data/eeg/R1111M/eeg.noreref/R1111M_FR1_0_22Jan16_1638&#39;, 100521) ...
  * time        (time) float64 -1.0 -0.998 -0.996 -0.994 -0.992 -0.99 -0.988 ...
Attributes:
    samplerate: 499.71
    gain: 0.531676
    format: int16
</pre></div>
</div>
</div>
<p>Let us plot this data. First lets import matplotlib and ensure that
ipython notebook can inline the plots</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [6]:
</pre></div>
</div>
<div class="input_area highlight-ipython2"><div class="highlight"><pre>
<span></span><span class="o">%</span><span class="k">matplotlib</span> inline

<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
</pre></div>
</div>
</div>
<p>Now we can do the plot:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [7]:
</pre></div>
</div>
<div class="input_area highlight-ipython2"><div class="highlight"><pre>
<span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">base_eegs</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">],</span><span class="n">base_eegs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:])</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>Out[7]:
</pre></div>
</div>
<div class="output_area highlight-none"><div class="highlight"><pre>
<span></span>[&lt;matplotlib.lines.Line2D at 0x10d48aad0&gt;]
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/examples_test_classifier_notebook-R1111M-presentation_13_1.png" src="../_images/examples_test_classifier_notebook-R1111M-presentation_13_1.png" />
</div>
</div>
<p>Notice that I refered to a <em>time</em> axis in the eeg data (<em>base_eegs</em>) as
<em>base_eegs[‘time’]</em>. Now let’s do two other plots one showing raw eeg
data for the channel with index 1 (i.e. second monopolar channels - as
we start counding from 0 in Python) and another the dirrefence the
voltage difference between the two channels</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [8]:
</pre></div>
</div>
<div class="input_area highlight-ipython2"><div class="highlight"><pre>
<span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">base_eegs</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">],</span><span class="n">base_eegs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,:])</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>Out[8]:
</pre></div>
</div>
<div class="output_area highlight-none"><div class="highlight"><pre>
<span></span>[&lt;matplotlib.lines.Line2D at 0x10d77be90&gt;]
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/examples_test_classifier_notebook-R1111M-presentation_15_1.png" src="../_images/examples_test_classifier_notebook-R1111M-presentation_15_1.png" />
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [9]:
</pre></div>
</div>
<div class="input_area highlight-ipython2"><div class="highlight"><pre>
<span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">base_eegs</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">],</span><span class="n">base_eegs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span><span class="o">-</span><span class="n">base_eegs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:])</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>Out[9]:
</pre></div>
</div>
<div class="output_area highlight-none"><div class="highlight"><pre>
<span></span>[&lt;matplotlib.lines.Line2D at 0x10d91ba90&gt;]
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/examples_test_classifier_notebook-R1111M-presentation_16_1.png" src="../_images/examples_test_classifier_notebook-R1111M-presentation_16_1.png" />
</div>
</div>
<p>Before applying <strong>MonopoarToBipolarFilter</strong> lets take a look at the
bipolar pairs</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [10]:
</pre></div>
</div>
<div class="input_area highlight-ipython2"><div class="highlight"><pre>
<span></span><span class="n">bipolar_pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>Out[10]:
</pre></div>
</div>
<div class="output_area highlight-none"><div class="highlight"><pre>
<span></span>rec.array([(&#39;001&#39;, &#39;002&#39;), (&#39;001&#39;, &#39;009&#39;), (&#39;002&#39;, &#39;003&#39;)],
          dtype=[(&#39;ch0&#39;, &#39;S3&#39;), (&#39;ch1&#39;, &#39;S3&#39;)])
</pre></div>
</div>
</div>
<p>and also let us examine monopolar channels:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [11]:
</pre></div>
</div>
<div class="input_area highlight-ipython2"><div class="highlight"><pre>
<span></span><span class="n">monopolar_channels</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>Out[11]:
</pre></div>
</div>
<div class="output_area highlight-none"><div class="highlight"><pre>
<span></span>array([&#39;001&#39;, &#39;002&#39;, &#39;003&#39;, &#39;004&#39;, &#39;005&#39;, &#39;006&#39;, &#39;007&#39;, &#39;008&#39;, &#39;009&#39;, &#39;010&#39;],
      dtype=&#39;|S3&#39;)
</pre></div>
</div>
</div>
<p>as you can see based onthe specification of the first bipolar pairs for
the first pairs we need to subtract values time series of channels with
labels ‘001’ and ‘002’, for the second one we subtract time series for
channels with labels ‘001’ and ‘009’, etc… We write a loop to do this
manually or we can use <strong>MonopolarToBipolarMapper</strong> that does exactly
these operations for us:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [12]:
</pre></div>
</div>
<div class="input_area highlight-ipython2"><div class="highlight"><pre>
<span></span><span class="n">m2b</span> <span class="o">=</span> <span class="n">MonopolarToBipolarMapper</span><span class="p">(</span><span class="n">time_series</span><span class="o">=</span><span class="n">base_eegs</span><span class="p">,</span> <span class="n">bipolar_pairs</span><span class="o">=</span><span class="n">bipolar_pairs</span><span class="p">)</span>
<span class="n">bp_eegs</span> <span class="o">=</span> <span class="n">m2b</span><span class="o">.</span><span class="n">filter</span><span class="p">()</span>
</pre></div>
</div>
</div>
<p>Let us check if indeed <strong>MonopolarToBipolarMapper</strong> does what we expect
and compare first two bipolar time series reported by the mapper to the
values we woudld obtain using manual calculations:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [13]:
</pre></div>
</div>
<div class="input_area highlight-ipython2"><div class="highlight"><pre>
<span></span><span class="n">first_bp</span> <span class="o">=</span> <span class="n">bp_eegs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span>
<span class="n">second_bp</span> <span class="o">=</span> <span class="n">bp_eegs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span>

<span class="n">first_bp_manual</span> <span class="o">=</span> <span class="n">base_eegs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span><span class="o">-</span><span class="n">base_eegs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span>
<span class="n">second_bp_manual</span> <span class="o">=</span> <span class="n">base_eegs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span><span class="o">-</span><span class="n">base_eegs</span><span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span>

<span class="n">numpy</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_array_equal</span><span class="p">(</span><span class="n">first_bp_manual</span><span class="p">,</span> <span class="n">first_bp</span><span class="p">)</span>
<span class="n">numpy</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_array_equal</span><span class="p">(</span><span class="n">second_bp_manual</span><span class="p">,</span> <span class="n">second_bp</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">first_bp</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">100</span><span class="p">],</span> <span class="n">first_bp</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">100</span><span class="p">],</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">first_bp_manual</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">100</span><span class="p">],</span> <span class="n">first_bp_manual</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">100</span><span class="p">],</span><span class="s1">&#39;r--&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>Out[13]:
</pre></div>
</div>
<div class="output_area highlight-none"><div class="highlight"><pre>
<span></span>[&lt;matplotlib.lines.Line2D at 0x10db48390&gt;]
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/examples_test_classifier_notebook-R1111M-presentation_24_1.png" src="../_images/examples_test_classifier_notebook-R1111M-presentation_24_1.png" />
</div>
</div>
<p>As you can see the action of the <strong>MonopolarToBipolarMapper</strong> matches
our “manual” computations so at this point we are ready to filter out
unwanted frequencies from our bipolar EEG spectrum. We will Apply
ButterworthFilter to supporess signal components in the 58 -62 Hz
bandwidth:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [14]:
</pre></div>
</div>
<div class="input_area highlight-ipython2"><div class="highlight"><pre>
<span></span><span class="n">b_filter</span> <span class="o">=</span> <span class="n">ButterworthFilter</span><span class="p">(</span><span class="n">time_series</span><span class="o">=</span><span class="n">bp_eegs</span><span class="p">,</span> <span class="n">freq_range</span><span class="o">=</span><span class="p">[</span><span class="mf">58.</span><span class="p">,</span> <span class="mf">62.</span><span class="p">],</span> <span class="n">filt_type</span><span class="o">=</span><span class="s1">&#39;stop&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">bp_eegs_filtered</span> <span class="o">=</span> <span class="n">b_filter</span><span class="o">.</span><span class="n">filter</span><span class="p">()</span>
</pre></div>
</div>
</div>
<p>Now we are ready to compute wavelet coefficients for our filtered time
series of bipolar EEG data. To do that we will use object called
<strong>MorletWaveltFilter</strong> that takes as its constructor parameters
<em>time_series</em> object for which we compute wavelets, an array of center
wavelet frequencies - <em>freqs</em> (here we are using 8 frequencies that are
logaritmically-spacedbetween 3 and 180 Hz) and optional parameter that
specifies the return value - here we return power so the <em>output</em>
parameter has value <em>‘power’</em> . To allow rudimentary benchmarking of the
code we will measure time it takes for the <strong>MorletWaveletFilter</strong> to
carry out its computations. Notice that the <em>filter()</em> function of the
<strong>MorletWaveletFilter</strong> returns two objects - power and phase arrays.
Since we are requesting power coeeficients only the phase array will be
set to <em>None</em>.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [15]:
</pre></div>
</div>
<div class="input_area highlight-ipython2"><div class="highlight"><pre>
<span></span><span class="n">s</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
<span class="n">wf</span> <span class="o">=</span> <span class="n">MorletWaveletFilter</span><span class="p">(</span><span class="n">time_series</span><span class="o">=</span><span class="n">bp_eegs_filtered</span><span class="p">,</span>
                         <span class="n">freqs</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mi">180</span><span class="p">),</span> <span class="mi">8</span><span class="p">),</span>
                         <span class="n">output</span><span class="o">=</span><span class="s1">&#39;power&#39;</span>
                         <span class="p">)</span>

<span class="n">pow_wavelet</span><span class="p">,</span> <span class="n">phase_wavelet</span> <span class="o">=</span> <span class="n">wf</span><span class="o">.</span><span class="n">filter</span><span class="p">()</span>
<span class="k">print</span> <span class="s1">&#39;TOTAL WAVELET TIME=&#39;</span><span class="p">,</span> <span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">s</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
total time wavelet loop:  123.173135996
TOTAL WAVELET TIME= 123.18047595
</pre></div></div>
</div>
<p>Now that we have wavelets computted we will remove buffer to truncate
those segments of time series for which wavelet convolution is
“contaminated” by so called edge effects. We will also tak logarithm of
the powers to handle the fact that spectral powers in the EEG signals
show power-law decay with increasing frequencies</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [16]:
</pre></div>
</div>
<div class="input_area highlight-ipython2"><div class="highlight"><pre>
<span></span><span class="n">pow_wavelet</span> <span class="o">=</span> <span class="n">pow_wavelet</span><span class="o">.</span><span class="n">remove_buffer</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">pow_wavelet</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">pow_wavelet</span><span class="o">.</span><span class="n">data</span><span class="p">);</span>
</pre></div>
</div>
</div>
<p>For the subsequent analysis we will need to reorder the axes of the
wavelet power array and compute the mean power across encoding epoch as
follows:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [17]:
</pre></div>
</div>
<div class="input_area highlight-ipython2"><div class="highlight"><pre>
<span></span><span class="n">pow_wavelet</span> <span class="o">=</span> <span class="n">pow_wavelet</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;events&quot;</span><span class="p">,</span><span class="s2">&quot;bipolar_pairs&quot;</span><span class="p">,</span><span class="s2">&quot;frequency&quot;</span><span class="p">,</span><span class="s2">&quot;time&quot;</span><span class="p">)</span>
<span class="n">mean_powers_nd</span> <span class="o">=</span> <span class="n">pow_wavelet</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">skipna</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [18]:
</pre></div>
</div>
<div class="input_area highlight-ipython2"><div class="highlight"><pre>
<span></span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="k">print</span> <span class="n">a</span>
<span class="n">a_z</span> <span class="o">=</span> <span class="n">zscore</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">a_z</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>Out[18]:
</pre></div>
</div>
<div class="output_area highlight-none"><div class="highlight"><pre>
<span></span>array([[-1., -1., -1., -1.],
       [ 0.,  0.,  0.,  0.],
       [ 1.,  1.,  1.,  1.]])
</pre></div>
</div>
</div>
<p>Once we computed mean powers we are essentially ready to compute
classifier, but first we will normalize features (i.e. mean power for
each combination of bipolar pair and spectral freqnency) accross the
events we will use to train the classifier. As a first step however we
will reshape mean_powers_nd array (with dimensions <em>events</em>,
<em>bipolar_pair</em>, <em>frequency</em>) to a 2-D array where one axis will
correspond to events and the other one will be a Cartesian product of
<em>bipolar_pair</em> and <em>frequency</em> axes:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [19]:
</pre></div>
</div>
<div class="input_area highlight-ipython2"><div class="highlight"><pre>
<span></span><span class="n">mean_powers_rs</span> <span class="o">=</span> <span class="n">mean_powers_nd</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">mean_powers_nd</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>first axis of <em>mean_powers_nd</em> corresponds to <em>events</em> and the second
one corresponds to Cartesian product of <em>bipolar_pair</em> and <em>frequency</em>
axes of the <em>mean_powers_nd</em>. At this point we are ready to z-score
along axis the first axis (axis with index 0 since we number axes
starting from 0 in Python) :</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [20]:
</pre></div>
</div>
<div class="input_area highlight-ipython2"><div class="highlight"><pre>
<span></span><span class="n">zscore_mean_powers</span> <span class="o">=</span> <span class="n">zscore</span><span class="p">(</span><span class="n">mean_powers_rs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>Let’s now check how many FR1 sessions we have in our data:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [21]:
</pre></div>
</div>
<div class="input_area highlight-ipython2"><div class="highlight"><pre>
<span></span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">base_events</span><span class="o">.</span><span class="n">session</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>Out[21]:
</pre></div>
</div>
<div class="output_area highlight-none"><div class="highlight"><pre>
<span></span>array([0, 1, 2])
</pre></div>
</div>
</div>
<p>We have 3 sessions so for the purpose of this tutorial we will use
session 0 and 1 as training data and session 2 as a test data Let’s
first construct mask arrays that we will use to perform selection along
axis corresponding to <em>events</em>. in essence the masking or selector
array, if you will, is a Boolean array that has number of elements equal
to the number of events. So when e.g. 20th element of this array is
<em>True</em> and 22nd is <em>False</em> the selection along <em>events</em> axis will pick
20th element but discard 22nd. IN the code below we are constructing
selector arrays for training and validation sessions and use this array
to select events and zscored powers for training and validation sessions</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [22]:
</pre></div>
</div>
<div class="input_area highlight-ipython2"><div class="highlight"><pre>
<span></span><span class="n">sess_min</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">sess_max</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">validation_sess_min</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">validation_sess_max</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">evs</span> <span class="o">=</span> <span class="n">base_events</span>
<span class="c1"># ----------------------- computting training and validation session mask arrays to facilitate event selection</span>
<span class="n">training_session_mask</span> <span class="o">=</span><span class="p">(</span><span class="n">evs</span><span class="o">.</span><span class="n">session</span><span class="o">&gt;=</span><span class="n">sess_min</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">evs</span><span class="o">.</span><span class="n">session</span><span class="o">&lt;=</span><span class="n">sess_max</span><span class="p">)</span>
<span class="n">validation_session_mask</span> <span class="o">=</span><span class="p">(</span><span class="n">evs</span><span class="o">.</span><span class="n">session</span><span class="o">&gt;=</span><span class="n">validation_sess_min</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">evs</span><span class="o">.</span><span class="n">session</span><span class="o">&lt;=</span><span class="n">validation_sess_max</span><span class="p">)</span>



<span class="c1"># --------------- selecting training events</span>
<span class="n">evs_sel</span> <span class="o">=</span> <span class="n">evs</span><span class="p">[</span><span class="n">training_session_mask</span><span class="p">]</span>
<span class="c1"># ---------- converting recalled field of the events into integer array (recalled items are 1&#39;s and non-recalled are 0s)</span>
<span class="n">recalls_array</span> <span class="o">=</span> <span class="n">evs_sel</span><span class="o">.</span><span class="n">recalled</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
<span class="c1"># --------------- selecting zscored powers for training data</span>
<span class="n">training_data</span> <span class="o">=</span> <span class="n">zscore_mean_powers</span><span class="p">[</span><span class="n">training_session_mask</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>

<span class="c1"># --------------- selecting validation events (out session data)</span>
<span class="n">evs_val</span> <span class="o">=</span> <span class="n">evs</span><span class="p">[</span><span class="n">validation_session_mask</span><span class="p">]</span>
<span class="c1"># --------------- selecting zscored powers for out session data</span>
<span class="n">validation_data</span> <span class="o">=</span> <span class="n">zscore_mean_powers</span><span class="p">[</span><span class="n">validation_session_mask</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>
<span class="c1"># ---------- converting recalled field of the events into integer array for out session data</span>
<span class="n">validation_recalls_array</span> <span class="o">=</span> <span class="n">evs_val</span><span class="o">.</span><span class="n">recalled</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>Now, we will construct <em>LogisticRegression</em> object that will fit
logistic regression coefficients for classifier features (<em>i.e.</em>,
zscored mean powers for each combination of bipoar pair and frequency):</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [23]:
</pre></div>
</div>
<div class="input_area highlight-ipython2"><div class="highlight"><pre>
<span></span><span class="n">lr_classifier</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">(</span><span class="n">C</span><span class="o">=</span><span class="mf">7.2e-4</span><span class="p">,</span> <span class="n">penalty</span><span class="o">=</span><span class="s1">&#39;l2&#39;</span><span class="p">,</span> <span class="n">class_weight</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="s1">&#39;liblinear&#39;</span><span class="p">)</span>
<span class="n">lr_classifier</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">training_data</span><span class="p">,</span> <span class="n">recalls_array</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="stderr output_area docutils container">
<div class="highlight"><pre>
/Users/m/miniconda/envs/ram/lib/python2.7/site-packages/sklearn/utils/class_weight.py:62: DeprecationWarning: The class_weight=&#39;auto&#39; heuristic is deprecated in 0.17 in favor of a new heuristic class_weight=&#39;balanced&#39;. &#39;auto&#39; will be removed in 0.19
  &#34; 0.19&#34;, DeprecationWarning)
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>Out[23]:
</pre></div>
</div>
<div class="output_area highlight-none"><div class="highlight"><pre>
<span></span>LogisticRegression(C=0.00072, class_weight=&#39;auto&#39;, dual=False,
          fit_intercept=True, intercept_scaling=1, max_iter=100,
          multi_class=&#39;ovr&#39;, n_jobs=1, penalty=&#39;l2&#39;, random_state=None,
          solver=&#39;liblinear&#39;, tol=0.0001, verbose=0, warm_start=False)
</pre></div>
</div>
</div>
<p>Once we have the coeeficients we can calculate AUC for the training
data.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [24]:
</pre></div>
</div>
<div class="input_area highlight-ipython2"><div class="highlight"><pre>
<span></span><span class="n">recall_prob_array</span> <span class="o">=</span> <span class="n">lr_classifier</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">training_data</span><span class="p">)[:,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">auc</span> <span class="o">=</span> <span class="n">roc_auc_score</span><span class="p">(</span><span class="n">recalls_array</span><span class="p">,</span> <span class="n">recall_prob_array</span><span class="p">)</span>
<span class="k">print</span> <span class="n">auc</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
0.841247996655
</pre></div></div>
</div>
<p>We can also plot ROC curve (false positives rate (FPR) vs. true
positives rate (TPR) ) for in-session (aka training) data</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [25]:
</pre></div>
</div>
<div class="input_area highlight-ipython2"><div class="highlight"><pre>
<span></span><span class="n">roc_curve_data_in</span> <span class="o">=</span> <span class="n">roc_curve</span><span class="p">(</span><span class="n">recalls_array</span><span class="p">,</span><span class="n">recall_prob_array</span><span class="p">)</span>
<span class="n">fpr_in</span> <span class="o">=</span> <span class="n">roc_curve_data_in</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">tpr_in</span> <span class="o">=</span> <span class="n">roc_curve_data_in</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fpr_in</span><span class="p">,</span><span class="n">tpr_in</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">((</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">),(</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">),</span><span class="s1">&#39;k--&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;FPR&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;TPR&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;In-session ROC-curve&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>Out[25]:
</pre></div>
</div>
<div class="output_area highlight-none"><div class="highlight"><pre>
<span></span>&lt;matplotlib.text.Text at 0x1122a1590&gt;
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/examples_test_classifier_notebook-R1111M-presentation_47_1.png" src="../_images/examples_test_classifier_notebook-R1111M-presentation_47_1.png" />
</div>
</div>
<p>However to asses reall value of the classifier wee need to test it on
the data differennt than the training data (out-session data). We
already have validation dataset solet’s use it to compute out-session
AUC and ROC curve:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [26]:
</pre></div>
</div>
<div class="input_area highlight-ipython2"><div class="highlight"><pre>
<span></span><span class="n">validation_recall_prob_array</span> <span class="o">=</span> <span class="n">lr_classifier</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">validation_data</span><span class="p">)[:,</span><span class="mi">1</span><span class="p">]</span>
<span class="n">validation_auc</span> <span class="o">=</span> <span class="n">roc_auc_score</span><span class="p">(</span><span class="n">validation_recalls_array</span><span class="p">,</span> <span class="n">validation_recall_prob_array</span><span class="p">)</span>
<span class="n">validation_auc</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>Out[26]:
</pre></div>
</div>
<div class="output_area highlight-none"><div class="highlight"><pre>
<span></span>0.70938852679237785
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [27]:
</pre></div>
</div>
<div class="input_area highlight-ipython2"><div class="highlight"><pre>
<span></span><span class="n">roc_curve_data_out</span> <span class="o">=</span> <span class="n">roc_curve</span><span class="p">(</span><span class="n">validation_recalls_array</span><span class="p">,</span> <span class="n">validation_recall_prob_array</span><span class="p">)</span>
<span class="n">fpr_out</span> <span class="o">=</span> <span class="n">roc_curve_data_out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">tpr_out</span> <span class="o">=</span> <span class="n">roc_curve_data_out</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fpr_out</span><span class="p">,</span><span class="n">tpr_out</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">((</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">),(</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">),</span><span class="s1">&#39;k--&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;FPR&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;TPR&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Out-Session ROC-curve&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>Out[27]:
</pre></div>
</div>
<div class="output_area highlight-none"><div class="highlight"><pre>
<span></span>&lt;matplotlib.text.Text at 0x11360c610&gt;
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/examples_test_classifier_notebook-R1111M-presentation_50_1.png" src="../_images/examples_test_classifier_notebook-R1111M-presentation_50_1.png" />
</div>
</div>
<p>Notice that in our example we used entire data set (training +
x-validation) during z-scoring. In real applications we will have
training data set which we will z-score and then then we will compute
z-score for the training dataset separately (possibly using variance
estimate for the training set). However in order to keep this tutorial
relatively simple i made simplifying assumption and zscored entire data
set.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [28]:
</pre></div>
</div>
<div class="input_area highlight-ipython2"><div class="highlight"><pre>
<span></span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start_time</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>Out[28]:
</pre></div>
</div>
<div class="output_area highlight-none"><div class="highlight"><pre>
<span></span>168.18399286270142
</pre></div>
</div>
</div>
<p>For logistic regression classifier we estimate probabilities that a
given event belongs to a a class of recalled events. The probability
formula is given by:</p>
<p><span class="math">\(P(x)=\left({1+e^{-\left(B+\sum w_i x_i\right)}}\right)^{-1}\)</span></p>
<p>which implies that we are looking for a dividing hyperplane that will
separate recalled and non-recalled events. The equation of this
hyperplane is simply</p>
<p><span class="math">\(B+\sum w_i x_i = 0\)</span></p>
<p>where <span class="math">\(B\)</span> is the intercept and <span class="math">\(w_i\)</span>‘s are weights
coefficients fitted by Logistic Regression algorithm. <span class="math">\(x_i\)</span>‘s are
features of the classifier - in our case <span class="math">\(x_i\)</span>‘s denote mean
powers for the i-th combination of spectral frequency and bipolar pair.
While ROC and AUC can give you a sense of classifier performance,
sometimes it is nice to be able to visualize how well the dividing
hyperplane separates data points belonging to thtw two classes (here
recalled vs non recalled) We can do it by projecting N dimensional space
into two dimennsions and plot dividing plane as well as individual ,
color-coded events. Let’s rewrite <span class="math">\(B+\sum w_i x_i = 0\)</span> as</p>
<p>$ B+X+Y = 0 $ where <span class="math">\(X = \sum_{i=0}^{i=200} w_i x_i\)</span> and
<span class="math">\(Y = \sum_{i=201}^{i=N} w_i x_i\)</span>. The number 200 is arbitrary
here. The idea is that we can treat a weighted sum of first n features
as one variable and the weighted sum of the remaining features as
another variable and plot those on a scatter plot. Here I picked
<span class="math">\(n=200\)</span> and <span class="math">\(N\)</span> denotes total number of features. Since $
B+X+Y = 0 $ is the exponent in the logistic probability function the
line along which the probability of the data point belonging to either
class is exactly 0.5 is called dividing line. It is not hard to see that
the equation of hte dividing line is exactly $ B+X+Y = 0 $ because when
the exponent is <span class="math">\(0\)</span> then</p>
<p><span class="math">\(P(x)=\left({1+e^{-0}}\right)^{-1}=0.5\)</span></p>
<p>Now, the data points that lie above the dividing line will get assigned
high probability (here, of being recalled) and those that lie below will
get assigned low probability</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [29]:
</pre></div>
</div>
<div class="input_area highlight-ipython2"><div class="highlight"><pre>
<span></span><span class="n">w_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">lr_classifier</span><span class="o">.</span><span class="n">coef_</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>Out[29]:
</pre></div>
</div>
<div class="output_area highlight-none"><div class="highlight"><pre>
<span></span>array([ 0.00228864, -0.00282099,  0.00977253, ..., -0.00185081,
        0.00932513,  0.00708427])
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [30]:
</pre></div>
</div>
<div class="input_area highlight-ipython2"><div class="highlight"><pre>
<span></span><span class="n">w</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">w_tmp</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">lr_classifier</span><span class="o">.</span><span class="n">intercept_</span>
<span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">=</span><span class="n">w_tmp</span>
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [35]:
</pre></div>
</div>
<div class="input_area highlight-ipython2"><div class="highlight"><pre>
<span></span><span class="n">x_project</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">training_data</span><span class="p">[:,:</span><span class="mi">200</span><span class="p">],</span><span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">201</span><span class="p">])</span>
<span class="n">y_project</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">training_data</span><span class="p">[:,</span><span class="mi">200</span><span class="p">:],</span><span class="n">w</span><span class="p">[</span><span class="mi">201</span><span class="p">:])</span>
<span class="n">recalled_ind</span> <span class="o">=</span> <span class="n">recalls_array</span><span class="o">==</span><span class="mi">0</span>
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [39]:
</pre></div>
</div>
<div class="input_area highlight-ipython2"><div class="highlight"><pre>
<span></span><span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>

<span class="c1"># plt.plot(x_line, y_line)</span>
<span class="c1"># plt.ylabel(&#39;uniform sample&#39;)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-.</span><span class="mi">5</span><span class="p">,</span><span class="o">.</span><span class="mi">5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x_project</span><span class="p">[</span><span class="n">recalled_ind</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="n">y_project</span><span class="p">[</span><span class="n">recalled_ind</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span> <span class="n">facecolors</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x_project</span><span class="p">[</span><span class="o">~</span><span class="n">recalled_ind</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="n">y_project</span><span class="p">[</span><span class="o">~</span><span class="n">recalled_ind</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span> <span class="n">facecolors</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>Out[39]:
</pre></div>
</div>
<div class="output_area highlight-none"><div class="highlight"><pre>
<span></span>&lt;matplotlib.collections.PathCollection at 0x114743310&gt;
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/examples_test_classifier_notebook-R1111M-presentation_58_1.png" src="../_images/examples_test_classifier_notebook-R1111M-presentation_58_1.png" />
</div>
</div>
<p>The analogous plot for the validation data would look as follows</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [38]:
</pre></div>
</div>
<div class="input_area highlight-ipython2"><div class="highlight"><pre>
<span></span><span class="n">x_project_val</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">validation_data</span><span class="p">[:,:</span><span class="mi">200</span><span class="p">],</span><span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">201</span><span class="p">])</span>
<span class="n">y_project_val</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">validation_data</span><span class="p">[:,</span><span class="mi">200</span><span class="p">:],</span><span class="n">w</span><span class="p">[</span><span class="mi">201</span><span class="p">:])</span>
<span class="n">validation_recalled_ind</span> <span class="o">=</span> <span class="n">validation_recalls_array</span><span class="o">==</span><span class="mi">0</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>

<span class="c1"># plt.plot(x_line, y_line)</span>
<span class="c1"># plt.ylabel(&#39;uniform sample&#39;)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-.</span><span class="mi">5</span><span class="p">,</span><span class="o">.</span><span class="mi">5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x_project_val</span><span class="p">[</span><span class="n">validation_recalled_ind</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="n">y_project_val</span><span class="p">[</span><span class="n">validation_recalled_ind</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span> <span class="n">facecolors</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x_project_val</span><span class="p">[</span><span class="o">~</span><span class="n">validation_recalled_ind</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="n">y_project_val</span><span class="p">[</span><span class="o">~</span><span class="n">validation_recalled_ind</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span> <span class="n">facecolors</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>Out[38]:
</pre></div>
</div>
<div class="output_area highlight-none"><div class="highlight"><pre>
<span></span>&lt;matplotlib.collections.PathCollection at 0x11381c610&gt;
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/examples_test_classifier_notebook-R1111M-presentation_60_1.png" src="../_images/examples_test_classifier_notebook-R1111M-presentation_60_1.png" />
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none"><div class="highlight"><pre>
<span></span>In [ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython2"><div class="highlight"><pre>
<span></span>
</pre></div>
</div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.1.dev3',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>